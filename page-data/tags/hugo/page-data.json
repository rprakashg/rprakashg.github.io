{"componentChunkName":"component---src-templates-tag-js","path":"/tags/hugo/","result":{"data":{"site":{"siteMetadata":{"title":"rprakashg.github.io","author":"RAM GOPINATHAN"}},"allMarkdownRemark":{"totalCount":3,"edges":[{"node":{"excerpt":"Hugo is a great OSS project that can be used to create static sites that are based on markdown files stored in a git repository. My personal blog is created using hugo and hosted on AWS S3. I recently…","html":"<p>Hugo is a great OSS project that can be used to create static sites that are based on markdown files stored in a git repository. My personal blog is created using hugo and hosted on AWS S3. I recently did some work to dockerize it and thought I'd write about it.</p>\n<p>First thing I needed to do was create a docker image with hugo installed so I can build my hugo site. For more info on the docker image see the Dockerfile contents below, you can also check out the git repository <a href=\"https://github.com/rprakashg/hugo-docker\">here</a>. As you can see from the below snippet, nothing major is going on here, I'm using golang alpine image as a base and then installing hugo and adding hugo to the system path.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">FROM golang:1.8.3-alpine\n\nENV HUGO_VERSION 0.25 \nENV HUGO_BINARY hugo_${HUGO_VERSION}_linux-64bit \nENV PATH=/usr/local/hugo:${PATH}\n\nRUN set -x \\\n    &amp;&amp; apk upgrade --update \\\n    &amp;&amp; apk add --update ca-certificates bash curl wget \\\n    &amp;&amp; rm -rf /var/cache/apk/* \\\n    &amp;&amp; mkdir /usr/local/hugo \\\n    &amp;&amp; wget https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/${HUGO_BINARY}.tar.gz -O /usr/local/hugo/${HUGO_BINARY}.tar.gz \\\n    &amp;&amp; tar xzf /usr/local/hugo/${HUGO_BINARY}.tar.gz -C /usr/local/hugo/ \\\n  &amp;&amp; rm /usr/local/hugo/${HUGO_BINARY}.tar.gz \\\n    &amp;&amp; rm -rf /tmp/* /var/cache/apk/* </code></pre></div>\n<p>In my Dockerfile for my personal hugo based blog I use multi stage builds feature in docker to generate static HTML using hugo. As you can see from below snipped that I'm using the \"hugo-docker\" image I created as builder image and create a directory named \"blog\" under /var/www/ and copy all files into that directory.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">FROM rprakashg/hugo-docker as builder\n\nRUN mkdir -p /var/www/blog\n\nCOPY . /var/www/blog</code></pre></div>\n<p>Next, we switch the working directory to \"/var/www/blog\" and run hugo command as shown in below snippet to generate the static HTML</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">WORKDIR /var/www/blog\n\nRUN hugo</code></pre></div>\n<p>Final image is built using the official nginx image from docker hub and we copy all generated HTML content from \"public\" folder into \"/usr/share/nginx/html\"</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">FROM nginx\n\nCOPY --from=builder /var/www/blog/public/ /usr/share/nginx/html</code></pre></div>\n<p>You can see the full docker file <a href=\"https://raw.githubusercontent.com/rprakashg/blog/master/Dockerfile\">here</a></p>\n<p>Lastly, I threw together couple of helpful bash scripts that I can use to build and run the container so I don't have to always remember the docker commands :)</p>\n<p>The cool thing about this is I can now run my blog anywhere, I use to host my blog previously in azure with Wordpress and MySQL, by using hugo I freed myself from dependency to web servers, runtimes, databases etc. but was still dependant on AWS S3 to host the generated static HTML content. Even though its pretty minor you are sort of locked into AWS. Docker gives me freedom to run it anywhere and I love it :)</p>\n<p>Hope that helps...</p>\n<p>Cheers,</p>\n<p>Ram</p>","id":"2c2aae05-bf5e-547b-9ff0-94d6e94bd8a0","frontmatter":{"title":"Dockerizing Hugo Sites","date":"November, 2017","tags":["hugo","docker","blog"]},"fields":{"slug":"/dockerizing-hugo-sites/"}}},{"node":{"excerpt":"Overview At T-Mobile we are starting to leverage Hugo which is an OSS static site generator tool for a few marketing type of sites. We are also huge Jenkins shop and run jenkins build slaves in docker…","html":"<h1>Overview</h1>\n<p>At T-Mobile we are starting to leverage <a href=\"http://gohugo.io\">Hugo</a> which is an OSS static site generator tool for a few marketing type of sites. We are also huge Jenkins shop and run jenkins build slaves in docker and Mesos/Marathon. We use S3 bucket for hosting content generated, cloudfront for global content delivery and route 53 for DNS. I've created a docker jenkins build slave image for building hugo projects in Jenkins. Image comes preloaded with Hugo and AWS CLI along with S3Cmd utility that is typically used for syncing content to S3 bucket.</p>\n<p>If you are using Hugo and Jenkins you'll find this image useful. Image is available in docker hub. You can run command below to pull the image down to your docker host that your are using with Jenkins. If you have any issues and or comments or questions let me know.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker pull rprakashg/hugo-jenkins-build-slave</code></pre></div>\n<p>Git repository for this image is <a href=\"http://github.com/rprakashg/hugo-jenkins-build-slave\">here</a></p>\n<p>Cheers,</p>\n<p>Ram</p>","id":"0d596cf2-ae32-5428-acf0-34a3b53e8567","frontmatter":{"title":"Jenkins Build Slave Image For Building Hugo Projects","date":"July, 2017","tags":["jenkins","docker","hugo"]},"fields":{"slug":"/hugo-jenkins-build-slave-image/"}}},{"node":{"excerpt":"Why changing the blogging platform There is two main reasons why I switched hugo for blogging. Speed (No more dynamic rendering of pages based on content stored in databases) Cost Hugo gives me…","html":"<h2>Why changing the blogging platform</h2>\n<p>There is two main reasons why I switched hugo for blogging.</p>\n<ul>\n<li>Speed (No more dynamic rendering of pages based on content stored in databases)</li>\n<li>Cost</li>\n</ul>\n<p>Hugo gives me freedom from needing any runtimes or databases which equates to speed since the entire site is just plain old HTML generated out of markdown files. Additionally my current wordpress blog hosted on Azure with ClearDB is running out of space available for free tier and is requiring me to upgrade to paid membership.</p>\n<p>I wanted to author blog posts using markdown format, VisualStudio Code provides great support for markdown authoring. Posts authored in markdown format are stored in a github <a href=\"http://github.com/rprakashg/blog\">repository</a>. Additionally I needed a continous publishing process that builds the site using hugo and publishes generated content when ever changes are committed to github repository.</p>\n<h2>Hosting platform</h2>\n<p>For hosting I decided to use AWS S3 with Cloudfront which gives me low cost storage and global content delivery.</p>\n<h2>Provisioning AWS components</h2>\n<p>Creating a new site and configuring it for blog was pretty easy and straightforward, I'm not going to go into details as there is plenty of articles and even documentation available at <a href=\"http://gohugo.io\">gohugo.io</a> site how ever I ran into some challenges with S3 + Cloudfront hosting. I came across a <a href=\"https://s3-us-west-2.amazonaws.com/cloudformation-templates-us-west-2/S3_Website_With_CloudFront_Distribution.template\">sample template</a> for S3 hosting but quickly ran into few limitations</p>\n<ol>\n<li>After I setup continuous publishing from Travis-CI I was getting access denied when accessing items in the bucket even though the bucket had public read enabled, this is primarily due to the fact that there is no concept of inheriting permissions in S3. I ended up having to create a bucket policy that granted read access to everything in the bucket to everyone</li>\n<li>Since one of my goal with this move was to setup continous publishing from Travis-CI when ever changes are committed to the github repository, it required me to create an AWS IAM user with full rights to S3 bucket hosting the content, additionally I needed to invalidate the cloudfront distribution when ever changes are published to the S3 bucket so user's can see fresh content, this required few cloudfront specific permissions granted to the user.</li>\n</ol>\n<p>Because of the reasons mentioned above and a few other flexibilities I was looking for, I ended up creating a custom cloudformation template. You can find the template <a href=\"http://github.com/rprakashg/cf-templates\">here</a>. If you want to leverage hugo for hosting your blog or other types of sites along with S3 + Cloudfront for hosting and content delivery, you will find this template very useful as it will get you almost 98% of the way. Once stack is created using the template you can simply copy the nameservers from the hosted zone created and update your domain settings in godaddy or what ever hosting provider you use.</p>\n<h2>Creating the stack</h2>\n<p>After you clone the <a href=\"http://github.com/rprakashg/cf-templates\">repo</a>, simply change the default template parameter values in template.parameters.json file to match your needs. Script uses AWS cli create-stack command to create the stack. If you are using OSX you can run command below to create the stack</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">./create-stack.sh</code></pre></div>\n<p>Once the stack is created successfully simply login to your AWS console and navigate to Route 53 hosted zone that was created by the cloudformation template and copy the name servers list and update your domain settings and replace nameservers with the one's you copied from the hosted zone recordset</p>\n<h2>Deleting stack</h2>\n<p>I've also included a simple script to delete the stack, script will grab the stack name from template.parameters.json file and deletes the stack using AWS cli delete-stack command. Run command below to delete stack</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">./delete-stack.sh</code></pre></div>\n<h2>Continuous publishing</h2>\n<p>As mentioned earlier one of my goal was to continuously publish to S3 bucket when new content or changes to existing content are committed to github repository. I'm using Travis-CI for this. If you are not familiar with Travis head over to <a href=\"http://travis-ci.org\">Travis-CI.org</a> for more info.</p>\n<p>See my <a href=\"http://github.com/rprakashg/blog/blob/master/.travis.yml\">.travis.yml</a> for reference.</p>\n<p>As you can see from my travis file I install hugo, then generate site content by running hugo command in script section. For deploying to S3 I'm using the S3 deployment support available in Travis-CI. For more information please <a href=\"https://docs.travis-ci.com/user/deployment/s3/\">see</a>. I've also added AWS Credential ID and Secret Key for the IAM build user that gets created as a part of creating the stack using the cloudformation template. AWS Credentials are stored encrypted. For more information on adding encrypted environment variables <a href=\"https://docs.travis-ci.com/user/environment-variables/#Defining-encrypted-variables-in-.travis.yml\">see</a>. Finally after successfully publishing content we invalidate cloudfront distribution by running a script. Download the cloudfront invalidation script <a href=\"https://github.com/rprakashg/blog/blob/master/cdn-invalidate.sh\">here</a>. Big thanks to <a href=\"https://www.whaletech.co/about/\">Ben Whaley</a> for the cloudfront invalidation script.</p>","id":"2f04cc5f-7992-53b5-a206-bc4a67fcba86","frontmatter":{"title":"New blog","date":"April, 2017","tags":["aws","s3","cloudfront","hugo","website","hosting"]},"fields":{"slug":"/new-blog/"}}}]}},"pageContext":{"tag":"hugo"}},"staticQueryHashes":["1468229134","1611934721"]}