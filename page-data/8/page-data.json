{"componentChunkName":"component---src-templates-post-list-js","path":"/8/","result":{"data":{"site":{"siteMetadata":{"title":"rprakashg.github.io","author":"RAM GOPINATHAN"}},"allMarkdownRemark":{"totalCount":30,"edges":[{"node":{"excerpt":"I made few enhancements over the weekend to seattle food truck bot. If you haven't read my previous post on seattle food truck bot I suggest you head over to this link Monday - Friday update a channel…","html":"<p>I made few enhancements over the weekend to seattle food truck bot. If you haven't read my previous post on seattle food truck bot I suggest you head over to this <a href=\"https://goo.gl/pzZWpP\">link</a></p>\n<ul>\n<li>\n<p>Monday - Friday update a channel in slack with food trucks available for a specific number of locations</p>\n<p>T-Mobile has multiple locations (Factoria, Bothell etc.) where we get food trucks for lunch. By automatically updating trucks for these locations we no longer need someone asking the bot to show trucks at these locations daily, Mon-Friday</p>\n<h3>How this is Implemented</h3>\n<p>Pretty simple, I found a golang package that implements cron spec parser and a job runner. For more information <a href=\"http://godoc.org/github.com/robfig/cron\">see</a></p>\n<p>Created a function that takes collection of locations as input and return a formatted message that can be posted to Slack channel. Using the Cron scheduler functionality in the cron package mentioned above, scheduled execution of this function at 8AM Mon-Fri and post message to slack channel configured. See sample code below</p>\n<div class=\"gatsby-highlight\" data-language=\"golang\"><pre class=\"language-golang\"><code class=\"language-golang\">if len(locations) &gt; 0 &amp;&amp; channel != &quot;&quot; {\n\tfmt.Println(&quot;Creating a new instance of Cron Scheduler&quot;)\n\tc = cron.New()\n\tc.AddFunc(&quot;0 0 08 * * mon-fri&quot;, func() {\n\t\tfmt.Println(&quot;Executing func in Cron&quot;)\n\t\tmessage, err := showTrucksForLocations(locations)\n\t\tif err != nil {\n\t\t\tfmt.Println(&quot;Failed to get trucks for locations&quot;)\n\t\t} else {\n\t\t\tlog.Println(&quot;Message : &quot;, message)\n\t\t\tresponseHandler(channel, message)\n\t\t}\n\t})\n\t//Start the Cron\n\tfmt.Println(&quot;Starting Cron&quot;)\n\tc.Start()\n}</code></pre></div>\n<p>Screenshot below shows slack message posted to \"#food\" channel by the BOT for T-Mobile Factoria and Bothell locations.\n<img src=\"/images/bot10.png?raw=true\" alt=\"\"></p>\n</li>\n<li>\n<p>Format time as AM/PM</p>\n<p>Previously when the bot shows trucks at a specified location it use to display time in 24hr format. This is now changed to show time as AM/PM. See example in screenshot below</p>\n<p><img src=\"/images/bot8.png?raw=true\" alt=\"\"></p>\n</li>\n</ul>\n<h2>Deployment</h2>\n<p>If you are deploying this bot in a docker container, when you run the container LOCATION_IDS and CHANNEL environment variables need to be set as shown in example below</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker run -d -e SLACK_TOKEN=&lt;replace with token> -e LOCATION_IDS=&lt;replace with comma delimited location ids you are interested> -e CHANNEL=&lt;replace with slack channel> rprakashg/foodtruck-slack-bot</code></pre></div>\n<p>If you are deploying this bot in heroku as I have done for our team, you can simply configure CHANNEL and LOCATION_IDS in heroku for the app under Config Variables in Settings tab as shown in screenshot below</p>\n<p><img src=\"/images/bot9.png?raw=true\" alt=\"\"></p>\n<p>Cheers,</p>\n<p>Ram</p>","id":"b9392a18-84fc-537c-bb10-9a9782855b77","frontmatter":{"title":"Updates To Foodtruck Bot","date":"August 13, 2017","tags":["slack","seattlefoodtruck","bot","golang"],"author":"Ram Gopinathan"},"fields":{"slug":"/updates-to-foodtruck-bot/"}}},{"node":{"excerpt":"Overview These days bot development is getting so popular especially with platforms like slack and teams that most companies are now using to collaborate with teams within the company as well as…","html":"<h1>Overview</h1>\n<p>These days bot development is getting so popular especially with platforms like slack and teams that most companies are now using to collaborate with teams within the company as well as external contractors and folks in external communities. I've been wanting to take a look at bot development for some time but never really just had a good use case until this last week. If you know me I'm a big foodie and I love the food trucks in Seattle. We get food trucks at T-Mobile locations in both Bellevue and Bothell, today what happens is begining of week we have a person that goes into <a href=\"http://www.seattlefoodtruck.com\">http://www.seattlefoodtruck.com</a> and prints out the food truck schedule for the whole week and pins it to a board in kitchen. If you want to know what's on today you either have to go to the seattlefoodtruck site or go look at the print out in kitchen and scroll through pages. What better use case for a bot eh?. That's exactly what I did this weekend.</p>\n<p>I decided to build the seattlefoodtruck bot using golang. With some research I found <a href=\"https://github.com/nlopes/slack\">this</a> golang package which supports most if not all of the api.slack.com REST calls, as well as the Real-Time Messaging protocol over websocket, pretty freakin cool :)</p>\n<p>Poking around the <a href=\"http://www.seattlefoodtruck.com\">SeattleFoodTruck</a> site in chrome developer tools I learned that there is a nice API that exposes all of the information such as neighborhoods, locations and trucks that are booked at those locations. Me be like my job is now easy :)</p>\n<h1>What does the seattlefoodtruck bot do?</h1>\n<p>You can ask the bot to show neighborhoods by typing command as shown below\n<img src=\"/images/bot1.png?raw=true\" alt=\"\"></p>\n<p>If everything went well bot will respond with list of neighborhoods where you can find trucks as shown below.</p>\n<p><img src=\"/images/bot2.png?raw=true\" alt=\"\"></p>\n<p>Once you find the neighborhood that you are close to from the list, you can then ask the bot to show locations at that neighborhood by typing command as shown below.\n<img src=\"/images/bot3.png?raw=true\" alt=\"\"></p>\n<p>If everything went well bot will respond with list of locations where you can find trucks as shown below. We will need the location ID to display food trucks at that specific location.\n<img src=\"/images/bot4.png?raw=true\" alt=\"\"></p>\n<p>At this point you can ask the bot to show trucks at that location by typing command as shown below.</p>\n<p><img src=\"/images/bot5.png?raw=true\" alt=\"\"></p>\n<p>If everything went well bot will show you food trucks booked at that location, date and time range when the food truck is available as well as display food categories and an image of the food truck as shown in screen capture below. Need to do some proper date time formatting but figured this will do for now :)\n<img src=\"/images/bot6.png?raw=true\" alt=\"\"></p>\n<p>Obviously once you identify the location closest to you, you can just simply run the command that shows trucks at a location. Typing help will show all the commands supported as shown in screen capture below</p>\n<p><img src=\"/images/bot7.png?raw=true\" alt=\"\"></p>\n<p>You can find the source code for the bot in this github <a href=\"https://github.com/rprakashg/foodtruck-slack-bot\">repository</a>. If you want to use this bot in your organizations channels, there is a Dockerfile included in the repository, simply docker build and run in your container platform and set SLACK_TOKEN environment variable. You will also need to configure the bot in Slack.</p>\n<p>This was a lot of fun recommend you guys to look at bot development you can automate lot of manual steps, as well as connect people with cloud services in an easy to use manner using platforms that are commonly used.</p>\n<p><em>Update 08/07/2017:</em> You can run the bot in heroku as well, today I'm running this for our team in Heroku. Travis file included in the repo can be leveraged to deploy to Heroku on checkin. Just need to update the API key. For more info see <a href=\"https://docs.travis-ci.com/user/deployment/heroku/\">Heroku Deployment</a></p>\n<p>Cheers,\nRam</p>","id":"2924a2fd-b0b8-5553-b6a8-278192e1f3ee","frontmatter":{"title":"Golang Slack Bot","date":"August 06, 2017","tags":["slack","seattlefoodtruck","bot","golang"],"author":"Ram Gopinathan"},"fields":{"slug":"/golang-slack-bot/"}}},{"node":{"excerpt":"Why? In Many enterprises leveraging Jenkins for running automated builds, it's quite common to have a central team providing Jenkins and other CI/CD tools as shared service. One of the issues that you…","html":"<h1>Why?</h1>\n<p>In Many enterprises leveraging Jenkins for running automated builds, it's quite common to have a central team providing Jenkins and other CI/CD tools as shared service. One of the issues that you quickly run into is that each development group within enterprise may have different platforms, frameworks, tools, libraries etc and to support the needs of everyone you end up provisioning jenkins build slaves for each group installing everything a particular group needs to be able to build/run jenkins jobs on these Jenkins slave nodes. Depending on number of groups you are supporting, this can get pretty difficult to manage. Thankfully for docker and the Jenkins community there is a docker plugin for Jenkins that can be used to dynamically provision a build slave as a docker container running on a remote docker host, run the build job and tear it down at the end of it. There a numerous benefits with this approach.</p>\n<ol>\n<li>Each development group can build the slave docker image according to their specification and through a CI process build/push the image to a docker registry keeping full ownership within the development team itself. No need to file any requests to get the tools you need installed on jenkins build slaves before your can create your CI/CD processes</li>\n<li>From an Operator's perspective you now have less number of build slaves to manage, preferably zero. I know our teams goal is to get to zero build slaves with fully dockerized approach.</li>\n</ol>\n<p>Here are the steps you can perform to leverage docker for dynamically provisioning a build slave as container:</p>\n<ul>\n<li>Install Docker Plugin</li>\n<li>Enable Docker Remote API on docker host</li>\n<li>Create a Docker image for Jenkins build slave</li>\n<li>Configure Jenkins</li>\n<li>Creating Jenkins job to run on docker</li>\n</ul>\n<h2>Install Docker Plugin</h2>\n<p>For the purposes of this post I installed a single node Jenkins server using Vagrant, I won't go too much into how I setup Jenkins as its all well documented and pretty easy to get setup. To install the docker plugin, login to Jenkins console and click on manage jenkins and from manage jenkins click on manage plugins. Switch to the available tab and you can scroll down or use the filter to find the docker plugin, select it to install. You may need to restart jenkins server for changes to get in effect.</p>\n<h2>Enable Docker Remote API on docker host</h2>\n<p>This is important step, plugin communicates with Docker via remote rest API which is turned off by default. You can enable it by simply adding below options to your dockerd startup</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</code></pre></div>\n<p>For the purposes of this demo I installed docker on centos/7 using Vagrant, if you installed docker on centos/7 you can update /usr/lib/systemd/system/docker.service file, look for ExecStart=/usr/bin/dockerd and add above options to dockerd. Restart docker by running commands below</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sudo systemctl daemon-reload\nsudo systemctl restart docker</code></pre></div>\n<h2>Create a Docker image for Jenkins build slave</h2>\n<p>First thing to keep in mind here is depending on the platform that you are using to build your application, choose an appropriate base image, there are lots of base images available for Java, Golang, Node etc. If none fits the bill start from scratch and add everything you need to it. Docker image should also have following:</p>\n<ol>\n<li>SSH server installed</li>\n<li>OpenJDK</li>\n<li>User that you can use to login with, typically \"jenkins\"</li>\n</ol>\n<p>Docker image should also expose port 22 for SSH and start sshd service when container is run. See an example Dockerfile that I use to create a jenkins slave image for running Hugo builds</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">FROM golang:1.8.3-alpine\n\nMAINTAINER Ramprakash.Gopinathan@t-mobile.com\n\nENV HUGO_VERSION 0.25\nENV HUGO_BINARY hugo_${HUGO_VERSION}_linux-64bit\nENV PATH=/usr/local/hugo:${PATH}\n\nRUN set -x \\\n    &amp;&amp; apk --no-cache update \\\n    &amp;&amp; apk --no-cache upgrade \\\n    &amp;&amp; apk --no-cache add git bash curl openssh python python-dev py-pip py-pygments openjdk8 wget\\\n    &amp;&amp; ssh-keygen -A \\\n    &amp;&amp; rm -rf /var/cache/apk/* \\\n    &amp;&amp; adduser -D jenkins \\\n    &amp;&amp; echo \"jenkins:jenkins\" | chpasswd \\\n    &amp;&amp; mkdir -p /var/run/sshd \\\n    &amp;&amp; mkdir /usr/local/hugo \\\n    &amp;&amp; wget https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/${HUGO_BINARY}.tar.gz -O /usr/local/hugo/${HUGO_BINARY}.tar.gz \\\n    &amp;&amp; tar xzf /usr/local/hugo/${HUGO_BINARY}.tar.gz -C /usr/local/hugo/ \\\n\t&amp;&amp; rm /usr/local/hugo/${HUGO_BINARY}.tar.gz \\\n    &amp;&amp; pip install --upgrade pip \\\n    &amp;&amp; pip install awscli \\\n    &amp;&amp; git clone https://github.com/s3tools/s3cmd.git /opt/s3cmd \\\n    &amp;&amp; ln -s /opt/s3cmd/s3cmd /usr/bin/s3cmd \n\nEXPOSE 22\n\nCMD [\"/usr/sbin/sshd\", \"-D\"]</code></pre></div>\n<p>Build the docker image and publish to your internal private docker registry, this allows you to login to your private registry from Docker host and pull the image down. You could always run docker save command to create a tar ball and scp this to docker host and run docker load to get the image on to the docker host.</p>\n<h2>Configure Jenkins</h2>\n<p>We now need configure Jenkins to use Docker for dynamically provisioning slave as containers on docker host. Login to your Jenkins console and click on \"Manage Jenkins\" option. From manage jenkins click on \"Configure System\" option and scroll all the way to the bottom of the page.\nUnder \"Cloud\" section click on \"Add a new cloud\" button. If the plugin is installed correctly you will see \"Docker\" option as shown below.</p>\n<p><img src=\"/images/jenkins3.jpg?raw=true\" alt=\"\"></p>\n<p>Enter information about your docker host. As I mentioned earlier I setup a docker host using vagrant for the purposes of this demo and created an entry in my /etc/hosts file to map the IP address of the VM to docker.local. You can test to make sure Jenkins server is able to talk to docker host by clicking on \"Test Connection\" button. See screenshot below:</p>\n<p><img src=\"/images/jenkins4.jpg?raw=true\" alt=\"\"></p>\n<p>Next enter image information such as full image name, Labels and credential to connect to the slave, this will be the user we created in docker file for the slave image. Labels allow us to restrict the builds. See screenshot below. I've added the java image \"evarga/jenkins-slave\" and the one I've created for running hugo builds, see more on that <a href=\"https://goo.gl/5ecm2V\">here</a></p>\n<p><img src=\"/images/jenkins5.jpg?raw=true\" alt=\"\"></p>\n<h2>Creating jenkins job to run on docker</h2>\n<p>At this point you are ready to run your build jobs on docker. Simply configure your job and specify Label Expression use docker as shown below.</p>\n<p><img src=\"/images/jenkins6.jpg?raw=true\" alt=\"\"></p>\n<p>Hope this helps, As usual any comments or questions please use the disqus option below</p>\n<p>Cheers,\nRam</p>","id":"c6a957a8-8548-50c4-991b-ca2486819827","frontmatter":{"title":"Using docker for dynamically provisioning jenkins build slaves and running build jobs","date":"July 08, 2017","tags":["jenkins","docker"],"author":"Ram Gopinathan"},"fields":{"slug":"/jenkins-build-slave-as-container/"}}}]}},"pageContext":{"limit":3,"skip":21,"numPages":12,"currentPage":8}},"staticQueryHashes":["1611934721","2366241629"],"slicesMap":{}}